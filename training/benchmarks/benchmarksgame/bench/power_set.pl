use Set::Object qw(set); sub powerset {    my $p = Set::Object->new( set() );    foreach my $i (shift->elements) {        $p->insert( map { set($_->elements, $i) } $p->elements );    }    return $p;} my $set = set(1, 2, 3);my $powerset = powerset($set); print $powerset->as_string, "\n";, package Set {    sub new       { bless { map {$_ => undef} @_[1..$#_] }, shift; }    sub elements  { sort keys %{shift()} }    sub as_string { 'Set(' . join(' ', sort keys %{shift()}) . ')' }    # ...more set methods could be defined here...}, use List::Util qw(reduce); sub powerset {    @{( reduce { [@$a, map { Set->new($_->elements, $b) } @$a ] }               [Set->new()], shift->elements )};} my $set = Set->new(1, 2, 3);my @subsets = powerset($set); print $_->as_string, "\n" for @subsets;, sub powerset {    @_ ? map { $_, [$_[0], @$_] } powerset(@_[1..$#_]) : [];}, use List::Util qw(reduce); sub powerset {    @{( reduce { [@$a, map([@$_, $b], @$a)] } [[]], @_ )}}, my @set = (1, 2, 3);my @powerset = powerset(@set); sub set_to_string {    "{" . join(", ", map { ref $_ ? set_to_string(@$_) : $_ } @_) . "}"} print set_to_string(@powerset), "\n";, use strict;use warnings;sub powerset(&@) {    my $callback = shift;    my $bitmask = '';    my $bytes = @_/8;    {       my @indices = grep vec($bitmask, $_, 1), 0..$#_;       $callback->( @_[@indices] );       ++vec($bitmask, $_, 8) and last for 0 .. $bytes;       redo if @indices != @_;    }} print "powerset of empty set:\n";powerset { print "[@_]\n" };print "powerset of set {1,2,3,4}:\n";powerset { print "[@_]\n" } 1..4;my $i = 0;powerset { ++$i } 1..9;print "The powerset of a nine element set contains $i elements.\n"; 
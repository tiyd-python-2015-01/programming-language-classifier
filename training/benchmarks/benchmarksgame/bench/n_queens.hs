import Control.Monadimport Data.List -- given n, "queens n" solves the n-queens problem, returning a list of all the-- safe arrangements. each solution is a list of the columns where the queens are-- located for each rowqueens :: Int -> [[Int]]queens n = map fst $ foldM oneMoreQueen ([],[1..n]) [1..n]  where    -- foldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a  -- foldM folds (from left to right) in the list monad, which is convenient for   -- "nondeterminstically" finding "all possible solutions" of something. the   -- initial value [] corresponds to the only safe arrangement of queens in 0 rows   -- given a safe arrangement y of queens in the first i rows, and a list of   -- possible choices, "oneMoreQueen y _" returns a list of all the safe   -- arrangements of queens in the first (i+1) rows along with remaining choices   oneMoreQueen (y,d) _ = [(x:y, delete x d) | x <- d, safe x]  where     -- "safe x" tests whether a queen at column x is safe from previous queens    safe x = and [x /= c + n && x /= c - n | (n,c) <- zip [1..] y] -- prints what the board looks like for a solution; with an extra newlineprintSolution y = do     let n = length y     mapM_ (\x -> putStrLn [if z == x then 'Q' else '.' | z <- [1..n]]) y     putStrLn "" -- prints all the solutions for 6 queensmain = mapM_ printSolution $ queens 6, import Control.Monad (foldM)import Data.List ((\\)) main :: IO ()main = mapM_ print $ queens 8 queens :: Int -> [[Int]]queens n = foldM f [] [1..n]    where      f qs _ = [q:qs | q <- [1..n] \\ qs, q `notDiag` qs]      q `notDiag` qs = and [abs (q - qi) /= i | (qi,i) <- qs `zip` [1..]], import Data.List (nub, permutations) -- checks if queens are on the same diagonal-- with [0..] we place each queen on her own rowcheck f = length . nub . zipWith f [0..] -- filters out results where 2 or more queens are on the same diagonal-- with [0..n-1] we place each queeen on her own columngenerate n = filter (\x -> check (+) x == n && check (-) x == n) $ permutations [0..n-1] -- 8 is for "8 queens"main = print $ generate 8
def hailstone n  seq = [n]  until n == 1    n = (n.even?) ? (n / 2) : (3 * n + 1)    seq << n  end  seqend puts "for n = 27, show sequence length and first and last 4 elements"hs27 = hailstone 27p [hs27.length, hs27[0..3], hs27[-4..-1]] # find the longest sequence among n less than 100,000n = (1 ... 100_000).max_by{|n| hailstone(n).length}puts "#{n} has a hailstone sequence length of #{hailstone(n).length}"puts "the largest number in that sequence is #{hailstone(n).max}", module Hailstone  ListNode = Struct.new(:value, :size, :succ) do    def each      node = self      while node        yield node.value        node = node.succ      end    end  end   @@sequence = {1 => ListNode[1,1]}   module_function   def sequence(n)    unless @@sequence[n]      m, ary = n, []      until succ = @@sequence[m]        ary << m        m = m.even? ? (m / 2) : (3 * m + 1)      end      ary.reverse_each do |m|        @@sequence[m] = succ = ListNode[m, succ.size + 1, succ]      end    end    @@sequence[n]  endend puts "for n = 27, show sequence length and first and last 4 elements"hs27 = Hailstone.sequence(27).entriesp [hs27.size, hs27[0..3], hs27[-4..-1]] # find the longest sequence among n less than 100,000n = (1 ... 100_000).max_by{|n| Hailstone.sequence(n).size}puts "#{n} has a hailstone sequence length of #{Hailstone.sequence(n).size}"puts "the largest number in that sequence is #{Hailstone.sequence(n).max}", func hailstone(n) {    var a = [n];    while (n > 1) {        a.append(n = (n %% 2 ? n/2 : (3*n + 1)));    };    return a;} # The hailstone sequence for the number 27var arr = hailstone(var nr = 27);say "#{nr}: #{arr[0 .. 3]} ... #{arr[-4 .. -1]} (#{arr.len})"; # The longest hailstone sequence for a number less than 100,000var h = [0, 0];99_999.times { |i|    (var l = hailstone(i).len) > h[1] && (        h = [i, l];    );}; printf("%d: (%d)\n", h...);
import qualified Data.Array as Arrimport qualified Data.Foldable as Foldimport qualified Data.List as Listimport Data.Maybe type Position = (Int, Int)type KnightBoard = Arr.Array Position (Maybe Int) toSlot :: Char -> Maybe InttoSlot '0' = Just 0toSlot '1' = Just 1toSlot _   = Nothing toString :: Maybe Int -> StringtoString Nothing  = replicate 3 ' 'toString (Just n) = replicate (3 - length nn) ' ' ++ nn  where    nn = show n chunksOf :: Int -> [a] -> [[a]]chunksOf _ [] = []chunksOf n xs = take n xs : (chunksOf n $ drop n xs) showBoard :: KnightBoard -> StringshowBoard board =  List.intercalate "\n" . map concat . List.transpose  . chunksOf (height + 1) . map toString $ Arr.elems board  where    (_, (_, height)) = Arr.bounds board toBoard :: [String] -> KnightBoardtoBoard strs = board  where    height = length strs    width  = minimum $ map length strs    board  = Arr.listArray ((0, 0), (width - 1, height - 1))             . map toSlot . concat . List.transpose $ map (take width) strs  add :: Num a => (a, a) -> (a, a) -> (a, a)add (a, b) (x, y) = (a + x, b + y) within :: Ord a => ((a, a), (a, a)) -> (a, a) -> Boolwithin ((a, b), (c, d)) (x, y) =  a <= x && x <= c &&  b <= y && y <= d -- Enumerate valid moves given a board and a knight's position.validMoves :: KnightBoard -> Position -> [Position]validMoves board position = filter isValid plausible  where    bound       = Arr.bounds board    plausible   = map (add position) [(1, 2), (2, 1), (2, -1), (-1, 2),                                      (-2, 1), (1, -2), (-1, -2), (-2, -1)]    isValid pos = within bound pos && maybe False (== 0) (board Arr.! pos) isSolved :: KnightBoard -> BoolisSolved = Fold.all (maybe True (/= 0)) -- Solve the knight's tour with a simple Depth First Search.solveKnightTour :: KnightBoard -> Maybe KnightBoardsolveKnightTour board = solve board 1 initPosition  where    initPosition = fst $ head $ filter ((== (Just 1)) . snd) $ Arr.assocs board    solve boardA depth position =      let boardB = boardA Arr.// [(position, Just depth)]      in if isSolved boardB        then Just boardB        else listToMaybe $ mapMaybe (solve boardB $ depth + 1)             $ validMoves boardB position tourExA :: [String]tourExA =  [" 000    "  ," 0 00   "  ," 0000000"  ,"000  0 0"  ,"0 0  000"  ,"1000000 "  ,"  00 0  "  ,"   000  "] tourExB :: [String]tourExB =  ["-----1-0-----"  ,"-----0-0-----"  ,"----00000----"  ,"-----000-----"  ,"--0--0-0--0--"  ,"00000---00000"  ,"--00-----00--"  ,"00000---00000"  ,"--0--0-0--0--"  ,"-----000-----"  ,"----00000----"  ,"-----0-0-----"  ,"-----0-0-----"] main :: IO ()main =  flip mapM_ [tourExA, tourExB]  (\board ->    case solveKnightTour $ toBoard board of    Nothing       -> putStrLn "No solution.\n"    Just solution -> putStrLn $ showBoard solution ++ "\n"), import Control.Monad.STimport qualified Data.Array.Base as ABimport qualified Data.Array.ST as ASTimport qualified Data.Array.Unboxed as AUimport qualified Data.List as List type Position = (Int, Int)type KnightBoard = AU.UArray Position Int toSlot :: Char -> InttoSlot '0' = 0toSlot '1' = 1toSlot _   = -1 toString :: Int -> StringtoString (-1) = replicate 3 ' 'toString n    = replicate (3 - length nn) ' ' ++ nn  where    nn = show n chunksOf :: Int -> [a] -> [[a]]chunksOf _ [] = []chunksOf n xs = take n xs : (chunksOf n $ drop n xs) showBoard :: KnightBoard -> StringshowBoard board =  List.intercalate "\n" . map concat . List.transpose  . chunksOf (height + 1) . map toString $ AU.elems board  where    (_, (_, height)) = AU.bounds board toBoard :: [String] -> KnightBoardtoBoard strs = board  where    height = length strs    width  = minimum $ map length strs    board  = AU.listArray ((0, 0), (width - 1, height - 1))             . map toSlot . concat . List.transpose $ map (take width) strs add :: Num a => (a, a) -> (a, a) -> (a, a)add (a, b) (x, y) = (a + x, b + y) within :: Ord a => ((a, a), (a, a)) -> (a, a) -> Boolwithin ((a, b), (c, d)) (x, y) =  a <= x && x <= c &&  b <= y && y <= d -- Solve the knight's tour with a simple Depth First Search.solveKnightTour :: KnightBoard -> Maybe KnightBoardsolveKnightTour board =  runST $ do    let      assocs = AU.assocs board      bounds = AU.bounds board     array <- (AST.newListArray bounds (AU.elems board))             :: ST s (AST.STUArray s Position Int)     let      initPosition = fst $ head $ filter ((== 1) . snd) assocs      maxDepth     = fromIntegral $ 1 + (length $ filter ((== 0) . snd) assocs)      offsets      =          [(1, 2), (2, 1), (2, -1), (-1, 2),           (-2, 1), (1, -2), (-1, -2), (-2, -1)]       solve depth position = do        if within bounds position        then do          oldValue <- AST.readArray array position          if oldValue == 0          then do            AST.writeArray array position depth            if depth == maxDepth            then return True            else do              -- This mapM-any combo can be reduced to a string of ||'s              -- with the goal of removing the allocation overhead due to consing              -- which the compiler may not be able to optimize out.              results <- mapM ((solve $ depth + 1) . add position) offsets              if any (== True) results              then return True              else do                AST.writeArray array position oldValue                return False          else return False        else return False     AST.writeArray array initPosition 0    result <- solve 1 initPosition    farray <- AB.unsafeFreeze array    return $ if result      then Just farray      else Nothing tourExA :: [String]tourExA =  [" 000    "  ," 0 00   "  ," 0000000"  ,"000  0 0"  ,"0 0  000"  ,"1000000 "  ,"  00 0  "  ,"   000  "] tourExB :: [String]tourExB =  ["-----1-0-----"  ,"-----0-0-----"  ,"----00000----"  ,"-----000-----"  ,"--0--0-0--0--"  ,"00000---00000"  ,"--00-----00--"  ,"00000---00000"  ,"--0--0-0--0--"  ,"-----000-----"  ,"----00000----"  ,"-----0-0-----"  ,"-----0-0-----"] main :: IO ()main =  flip mapM_ [tourExA, tourExB]  (\board ->    case solveKnightTour $ toBoard board of    Nothing       -> putStrLn "No solution.\n"    Just solution -> putStrLn $ showBoard solution ++ "\n")
import Data.Setimport Control.Monad powerset :: Ord a => Set a -> Set (Set a)powerset = fromList . fmap fromList . listPowerset . toList listPowerset :: [a] -> [[a]]listPowerset = filterM (const [True, False]), powerset [] = [[]]powerset (head:tail) = acc ++ map (head:) acc where acc = powerset tail, powerset = foldr (\x acc -> acc ++ map (x:) acc) [[]], import qualified Data.Set as Settype Set=Set.SetunionAll :: (Ord a) => Set (Set a) -> Set aunionAll = Set.fold Set.union Set.empty --slift is the analogue of liftA2 for sets.slift :: (Ord a, Ord b, Ord c) => (a->b->c) -> Set a -> Set b -> Set cslift f s0 s1 = unionAll (Set.map (\e->Set.map (f e) s1) s0) --a -> {{},{a}}makeSet :: (Ord a) => a -> Set (Set a)makeSet = (Set.insert Set.empty) . Set.singleton.Set.singleton powerSet :: (Ord a) => Set a -> Set (Set a)powerSet = (Set.fold (slift Set.union) (Set.singleton Set.empty)) . Set.map makeSet,  Prelude Data.Set> powerSet fromList [1,2,3]fromList [fromList [], fromList [1], fromList [1,2], fromList [1,2,3], fromList [1,3], fromList [2], fromList [2,3], fromList [3]]
from itertools import permutations n = 8cols = range(n)for vec in permutations(cols):    if n == len(set(vec[i]+i for i in cols)) \         == len(set(vec[i]-i for i in cols)):        print ( vec ), def board(vec):    print ("\n".join('.' * i + 'Q' + '.' * (n-i-1) for i in vec) + "\n===\n"), # From: http://wiki.python.org/moin/SimplePrograms, with permission from the author, Steve HowellBOARD_SIZE = 8 def under_attack(col, queens):    return col in queens or \           any(abs(col - x) == len(queens)-i for i,x in enumerate(queens)) def solve(n):    solutions = [[]]    for row in range(n):        solutions = [solution+[i+1]                       for solution in solutions                       for i in range(BOARD_SIZE)                       if not under_attack(i+1, solution)]    return solutions for answer in solve(BOARD_SIZE): print(list(enumerate(answer, start=1))), BOARD_SIZE = 8 def under_attack(col, queens):    return col in queens or \           any(abs(col - x) == len(queens)-i for i,x in enumerate(queens)) def solve(n):    solutions = [[]]    for row in range(n):        solutions = (solution+[i+1]                       for solution in solutions # first for clause is evaluated immediately,                                                 # so "solutions" is correctly captured                       for i in range(BOARD_SIZE)                       if not under_attack(i+1, solution))    return solutions answers = solve(BOARD_SIZE)first_answer = next(answers)print(list(enumerate(first_answer, start=1))), def queens(n):    a = list(range(n))    up = [True]*(2*n - 1)    down = [True]*(2*n - 1)    def sub(i):        nonlocal a, up, down        for k in range(i, n):            j = a[k]            p = i + j            q = i - j + n - 1            if up[p] and down[q]:                if i == n - 1:                    yield tuple(a)                else:                    up[p] = down[q] = False                    a[i], a[k] = a[k], a[i]                    yield from sub(i + 1)                    up[p] = down[q] = True                    a[i], a[k] = a[k], a[i]    yield from sub(0)